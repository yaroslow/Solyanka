Validate models, submodels and members
===

### Description

Validator is an actor that helps to admit model and its members by imposing restrictions. Constraints assist to restrict and protect 'pure' inner world (application/domain layers) from 'dirty' outside world (presentation layer - API models, broker consumers data, etc.).

### Install

For using Validator install [Solyanka.Validator with NuGet](https://www.nuget.org/packages/Solyanka.Validator) to your project:
By Nuget Package Manager:

    Install-Package Solyanka.Validator

By .Net command line interface:

    dotnet add package Solyanka.Validator

### Create Validator of model

`Validator` can be created by two ways:

1) Just create `Validator<T>`:
```csharp
    ...
    //other code

    var validator = Validator<User>.Create();

```
Such creation has no consequences and may be used further.

2) Create and add validator to cache through `Validator` static class:
```csharp
    ...
    //other code

    var validator = Validator.Create<User>();
```
Such creation also add `Validator<T>` to cache for reusing it.

User model for example:
```csharp
    public class User
    {
        [Required(ErrorMessage = "Email incorrect")]   
        public string Email { get; set; }
        
        public Credentials Credentials { get; set; }
    }

    public class Credentials
    {
        [MaxLength(50, ErrorMessage = "User name length exceed 50")]
        public string Name { get; set; }
    }
```

### Create constraints for model and members

```csharp
    ...
    //other code

    var validator = Validator.Create<User>()
        .Constrain(u => u.Email != null, "Email incorrect")
        .For(u => u.Credentials)
            .Constrain(c => c.Name.Length < 50, "User name length exceed 50")
            .Compress();

    var user = new User()
    {
        Email = "test@test.com",
        Credentials = new Credentials
        {
            Name = "Test"
        }
    };

    var result = validator.Validate(user);
    
    result.RaiseAggregated();
```

* `Constrain` method imposes a restriction on property or field
* `For` method create ValidatorMember<T> to impose restrictions on submodels
* `Compress` method is a final step to pack all created constraints for submodels. It returns validator root
* `Validate` method creates validation result that indicates success or failure and additional info

* `RaiseAggregated` method throws an `AggregatedException` combined `ValidationException`s if validation failed
* `Raise` method throws the first `ValidationException` if validation failed


### Add validation attributes to Validator constraints

```csharp
    ...
    //other code

    var validator = Validator.Create<User>()
        .ConstrainAttributes()
        .For(u => u.Credentials)
            .ConstrainAttributes()
            .Compress();

    var user = new User()
    {
        Email = "test@test.com",
        Credentials = new Credentials
        {
            Name = "Test"
        }
    };

    var result = validator.Validate(user);
    
    result.RaiseAggregated();
```

* `ConstrainAttributes` method convert attributes to inner validator constraints

### Stop on the first error

The validator passes through all restrictions by default. This behaviour can be changed by setting parameter `firstErrorStop` to `true`:

```csharp
    ...
    //other code

    var validator = Validator.Create<User>()
        .ConstrainAttributes()
        .For(u => u.Credentials)
            .ConstrainAttributes()
            .Compress();

    var user = new User()
    {
        Email = "test@test.com",
        Credentials = new Credentials
        {
            Name = "Test"
        }
    };

    var result = validator.Validate(user, true);
    
    result.RaiseAggregated();
```

### Defined validation helpers

There are some defined validation helpers:
- For objects:
* IsNull
* IsNotNull
* IsEqual
* IsNotEqual

- For strings:
* IsEmpty
* IsNotEmpty
* IsNullOrEmpty
* IsNotNullOrEmpty
* IsNullOrWhiteSpace
* IsNotNullOrWhiteSpace
* IsEqual
* IsNotEqual
* HasLength
* HasLengthRange
* HasMinLength
* HasMaxLength
* IsMatch

- For ints (or convertable to int):
* IsLessThan
* IsLessThanOrEqual
* IsGreaterThan
* IsGreaterThanOrEqual
* IsBetween

- For doubles (or convertable to double):
* IsLessThan
* IsLessThanOrEqual
* IsGreaterThan
* IsGreaterThanOrEqual
* IsBetween

- For specific cases:
* IsEmail
* IsNotEmptyGuid
* IsEnumValueDefined
* IsEnumNameDefined

For example:
```csharp
    ...
    //other code

    var validator = Validator.Create<User>()
        .Constrain(u => u.Email.IsNotNull() && u.Email.IsEmail(), "Email incorrect")
        .For(u => u.Credentials)
            .Constrain(c => c.Name.HasMaxLength(50), "User name length exceed 50")
            .Compress();
```

### Benchmark

Will be soon